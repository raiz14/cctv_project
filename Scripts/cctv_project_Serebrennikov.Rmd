---
title: "CCTV_Project"
author: "Serebrennikov_Dmitry"
date: "26.09.2019"
institute: "ИПП ЕУ СПб"
output: html_document
---

Список рабочих задач:
 1. Загрузить данные и отобразить их в R 
 2. Т.к. подсчет на всем объеме данных занимает много времени - создать выборку.
 3. Научиться забирать из данных точки интереса в k метрах (где k=150 м.) вокруг каждой камеры.
 4. Научиться представлять полученные данные в виде длинной плоской таблицы формата «идентификатор камеры-идентификатор точки интереса в OpenStreetMap-тип точки интереса-иные поля точки интереса-расстояние от точки интереса до камеры».

--

# При работе я больше всего ориентировался на следующие материалы:
# https://tsamsonov.github.io/r-geo-course/vector-analysis.html
# https://geocompr.robinlovelace.net/geometric-operations.html

```{r}
setwd("C:/Literature/Police studies & Law Enforcement/CCTV-Moscow_IRL_Project/data/Off/data")

getwd()

require("knitr")
opts_knit$set(root.dir = "C:/Literature/Police studies & Law Enforcement/CCTV-Moscow_IRL_Project/data/Off/data")


library(sf)
library(jsonlite)
library(geojsonsf)
library(geojsonio)
```

1. Выгрузка данных (на этом этапе у меня были самые существенные проблемы, которые разрешились примерно во время написания этих строк)
 Загрузим самые необходимые в работе данные:

```{r}
roads <-  st_read("highway-line.shp") # Дороги
poi <-  st_read("poi-point.shp") # Точки интереса
rayons <-  st_read("boundary-polygon-lvl8.shp") # Границы районов
stations <-  st_read("railway-station-point.shp") # Станции 
water <-  st_read("water-line.shp") # Водоемы и реки
cctv <- st_read("cctv_2019-06-27.geojson)") - #Камеры
```


 2. Выборка
 https://www.r-bloggers.com/clipping-spatial-data-in-r/
 https://www.rdocumentation.org/packages/sp/versions/1.3-1/topics/SpatialPoints

 Изначально, я пытался сделать выборку через bounding box:
```{r}
frame <-  roads %>% st_bbox(c(xmin = 55.765290, xmax = 55.782734, ymax = 37.687516, ymin = 37.640145), crs = st_crs(4326)) %>% st_as_sfc() %>% st_geometry()
```
 В результате долгих попыток ничего не вышло.
 Тогда я решил сделать выборку по району (Бассманному) + cделаем выборку всех остальных слоев по Бассманному району:
```{r}
rayons <- rayons %>% filter(OSM_ID == "2162195") %>% st_geometry() 
poi <- poi[rayons, ]
roads <- roads[rayons, ]
stations <- stations[rayons,]
water <- water[rayons, ]
```

Строим буферную зону, используя функцию st_buffer() из пакета sf. Т.к. на момен написания этих строк у меня была проблема с данными камер, я решил строить зоны вокруг станций (для учебных целей):

```{r}
zone = st_buffer(stations, dist = 150) 

```

Сделаем отбор точек интереса по буферным зонам

```{r}
selected.poi = st_intersect(poi, zone)
View(selected.poi)
```

(!)
И тут я столкнулся с проблемой. Почему-то точки интереса не отбираются. При этом на других данных (из которых я взял основу выполнения этой задачи - https://tsamsonov.github.io/r-geo-course/vector-analysis.html), эта команда работала и собирала данные.

Так же есть проблема №2. Когда st_buffer собирал данные (на данных из примеров по ссылке выше), то не делал сцепки между конкретной станцией и точками интереса, а выдавал просто таблицу с точками интереса, попавшими во все буфферы (но это, насколько я понимаю, решается не так сложно).

На всякий случай визуализируем то, что получилось:
Убираем большие поля на карте и делаем основу карты в виде функции:

```{r}
par(mar = c(0,0,0,0))
plotBasemap = function(){
  plot(rayons)
  plot(water %>% st_geometry(), 
       col = "lightskyblue1",
       border = "lightskyblue3",
       add = TRUE)
  plot(roads %>% st_geometry(),
       col = "gray70",
       add = TRUE)
  plot(poi %>% st_geometry(), 
       col = "deepskyblue4", 
       pch = 20, 
       cex = 0.3, 
       add = TRUE)
  plot(stations %>% st_geometry(), 
       col = "slategray4", 
       pch = 20, 
       cex = 2, 
       add = TRUE)
}
```

Визуализируем то, что получилось с буфферными зонами вокруг станций:

```{r}
plotBasemap()
plot(stations %>% st_geometry(), 
     col = "red", 
     pch = 20, 
     cex = 4, 
     add = TRUE)
plot(zone %>% st_geometry(),
     col = adjustcolor("sienna3", alpha.f = 0.5),
     border = "sienna3",
     add = TRUE)
```

Красные точки - не буффер, а alpha.f = 0.5. Буффер не работает.
Получившиеся выбранные точки интереса - тот же датасет, что и простые точки интереса:

```{r}
plot(selected.poi %>% st_geometry(), 
     col = "sienna4", 
     pch = 20, 
     cex = 0.5, 
     add = TRUE)
```

Итого две проблемы:
 1. Работа функции st_buffer на используемых данных
 2. Проблема вывода итоговой таблицы точек интереса (легче решаемая моими силами, чем предыдущая)
 